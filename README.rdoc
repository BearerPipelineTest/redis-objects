= Redis Atoms - Leverage Redis to handle counters and atomicity in your app

Redis is great _not_ as a replacement for MySQL, but as a way to perform atomic
operations on _individual_ data structures, like counters, lists, and sets.  People
that are wrapping ORM's around Redis are missing the point.  Plus, their performance
can be quite poor (worse than a DB), since a save is 10+ network calls.

This gem, instead, provides atomic methods that you can use *with* your existing
ActiveRecord/DataMapper/etc models, or in classes that have nothing to do with an
ORM or even a database, but need support for atomic operations that can scale.

The only requirement Redis::Atoms has is that your class must provide an +id+ instance
method which returns the ID for that instance.  ActiveRecord, DataMapper, and MongoRecord
all have id methods which are known to be suitable.  Since +id+ can be anything as
far as Redis::Atoms is concerned, you can even write an +id+ method of your own.

== Installation

    gem install gemcutter
    gem tumble
    gem install redis-atoms
   
== Example

    # In your app initialization
    require 'redis'
    require 'redis/atoms'
    Redis::Atoms.redis = Redis.new(:host => 127.0.0.1, :port => 6379)

    # Include atoms in any type of class
    class Roster < ActiveRecord::Base
      include Redis::Atoms
      
      counter :available_slots, :start => 10
      counter :max_pitchers, :start => 0, :limit => 3
      lock :reorder, :timeout => 5
    end

    # Usage (to handle concurrency)
    @roster = Roster.find(1)
    if @roster.decrement_available_slots >= 0
      # do stuff
    else
      # reset counter state
      @roster.increment_available_slots
    end

    # Another way to do the above (handles exceptions)
    @roster.if_available_slots_left do
      # atomic block
    end

    # Similar functionality for incrementing counters
    @roster.if_max_pitchers_limit do
      # atomic block
    end

    # Serialize any "reorder" operation since it affects multiple records
    @roster.lock_reorder do
      # atomic block
    end

    # Class methods work too - notice we replace ActiveRecord counters
    Roster.increment_counter :available_slots, @roster.id
    Roster.decrement_counter :available_slots, @roster.id, 2

    # And class-level if/lock (saves a DB fetch)
    Roster.if_counter_left(:available_slots, @roster.id, 0) do
      # atomic block
    end
    Roster.obtain_lock :reorder, @roster.id do
      # atomic block
    end

== You Likely Have Some Huge Bugs

You are probably not handling atomic operations properly in your app, and 
probably have some nasty lurking race conditions.  The worst part is these
will get worse as your user count increases, are difficult to reproduce,
and usually happen to your most critical pieces of code.

Let's assume you're writing an app to enable students to enroll in courses.
You need to ensure that no more than 30 people can sign up for a given class.
In your enrollment code, you have something like this:

    @course = Course.find(1)
    if @course.num_students < 30
      @course.course_students.create(:student_id => 101)
      @course.num_students += 1
      @course.save!
    else
      # course is full
    end
    
You're screwed.  You now have 32 people in your 30 person class, and you have
no idea what happened.

"Well no duh," you're saying, "even the {ActiveRecord docs mention locking}[http://api.rubyonrails.org/classes/ActiveRecord/Locking/Pessimistic.html],
so I'll just use that."

    @course = Course.find(1, :lock => true)
    if @course.num_students < 30
      # ...

Nice try, but this still doesn't work.  Locking only stops other _updates_ from
happening.  It does nothing about _access_.  You could still have 13 people
simultaneously hit that "< 30" check.

And even if it did work, now you've introduced other issues.  Any other piece of
code in your entire app that needs to update _anything_ about the course - maybe
the course name, or start date, or location - is now serialized.  If you need high
concurrency, you're still screwed.

== The Root Down

It's worth understanding the root issue, and how to address it.

Race conditions arise from the difference in time between *evaluating* and *altering*
a value.  In our example, we did a find on the record, then checked the value, then
did a save.  The more lines of code between those operations, and the higher your user
count, the bigger the window of opportunity for another client to get the data in an
inconsistent state.

Basically any code that does this:

    a = 10
    if a < 15
      a += 1
      
Has a race condition.  Sometimes these don't matter, since you're the only one
operating on a piece of data.  For example, this probably doesn't matter:

    @post = Post.create(:user_id => 372, :title => "Whattup", ...)
    @user.total_posts += 1  # update my post count
    
Because a user is only creating their own posts.

But this _would_ matter:

    @post = Post.create(:user_id => 372, :title => "Whattup", ...)
    @blog.total_posts += 1  # update post count across all users

Because multiple users could be adding posts concurrently.

In a traditional RDBMS, you can handle counters atomically by firing off an
update statement that self-references the column:

    update users set total_posts = total_posts + 1 where id = 372

You may have seen {ActiveRecord's increment_counter class method}[http://api.rubyonrails.org/classes/ActiveRecord/Base.html#M002278],
which wraps this functionality.  This approach is cumbersome, though,
since your @user object will no longer be in sync.  And if you do:

    User.increment_counter :total_posts, @user.id
    if @user.total_posts >= 100
      # award them a gold star!

Now the DB says 100, but your @user object still says 99, and the user doesn't
get their gold star.  Sad faces all around.

== A Better Way

Bottom line: Any operation that changes a value *must* return that value in
the _same_ _operation_ for it to be atomic.  If you do a separate get then set,
or set then get, you're open to a race conditions, and generally getting your
data in a weird state.  

There are very few systems that support a "getset" type operation, and Redis
is one of them (Oracle sequences are another).  To best address this issue,
what you need is a way to handle _specific_ conditions atomically, which
is what this gem provides.

Think of the specific things that you need to ensure.  Many of these will
reduce to numeric operations.  For example:

* No more than 30 students in a course
* Must have more than 2 but less than 6 people in a game
* A chat room has a max of 50 people
* Correctly recording the total number of blog posts
* Only allowing one piece of code to reorder a large dataset at a time

All except the last one can be implemented with counters.  The last one 
will need a carefully placed lock.

The best way I've found to balance atomicity and concurrency is to split
your counters into two types:

* Counters users see (eg, +current_students+).  These typically increment.
* Counters you base logic on (eg, +remaining_slots+).  These typically decrement.

The reason you want two counters is you'll need to change the value of the logic
counter *first*, _before_ checking it, to address any race conditions.  This means
the value can get wonky momentarily, which just means you don't want to display it.

So, taking our +Course+ example:

    class Course < ActiveRecord::Base
      include Redis::Atoms
      
      counter :remaining_slots, :start => 30
      counter :current_students
    end

Then:

    @course = Course.find(1)
    @course.if_remaining_slots_left do
      @course.course_students.create!(:student_id => 101)
      @course.increment_current_students
    end

That way, your views get consistent information about the course, since
+current_students+ will only be incremented on success.  There is still a
race condition where +current_students+ could be less than the real number
of +CourseStudent+ records, but since you'll be displaying these values in a view
(after both are updated) you shouldn't see this manifest in real-world usage.

For more examples, see the examples/ folder.

== Author

Copyright (c) 2009 {Nate Wiger}[http://nate.wiger.org].  All Rights Reserved.
Released under the {Artistic License}[http://www.opensource.org/licenses/artistic-license-2.0.php].
