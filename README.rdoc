= Redis Atoms - Leverage Redis to handle counters and atomicity in your app

Redis is great _not_ as a replacement for MySQL, but because it provides atomic
operations on _individual_ data structures, like counters, lists, and sets.  People
that are wrapping ORM's around Redis are missing the point.  This gem, instead,
provides methods that you can use *with* your existing ActiveRecord/DataMapper/etc
models, or in code that has nothing to do with an ORM or even a database, but needs
support for atomic operations that can scale.

The only requirement that Redis::Atoms has is your class must provide an +id+ method
which returns the ID for that instance.  ActiveRecord, DataMapper, and MongoRecord
all have id methods which are known to be suitable.

== Installation

    gem install gemcutter
    gem tumble
    gem install redis-atoms
   
== Example

    # Somewhere in your app initialization
    require 'redis'
    require 'redis/atoms'
    Redis::Atoms.redis = Redis.new(:host => 127.0.0.1, :port => 6379)

    # Include atoms in any type of class
    class Roster < ActiveRecord::Base
      include Redis::Atoms
      
      counter :available_slots, :start => 10
      lock :resort, :timeout => 5
    end

    # Usage
    @roster = Roster.find(1)
    if @roster.decrement_available_slots >= 0
      # do stuff
    else
      # reset counter state
      @roster.increment_available_slots
    end

    # Another way to do the above (handles exceptions)
    # Default is 0 and can be omitted
    @roster.if_available_slots_left(0) do
      # atomic block
    end

    # Serialize any "resort" operation since it affects multiple records
    @roster.lock_resort do
      # atomic block
    end

    # Class methods work too - notice these replace ActiveRecord methods
    Roster.increment_counter :available_slots, @roster.id
    Roster.decrement_counter :available_slots, @roster.id, 2
    Roster.if_counter(:available_slots, @roster.id, :>, 0) do
      # atomic block
    end
    Roster.obtain_lock :resort, @roster.id do
      # atomic block
    end

== You Are Probably Doing Things Wrong

You are probably not handling atomic operations properly in your app.  Even if
you're using an ACID database like MySQL, this doesn't guarantee that your
app doesn't have significant race conditions.  The worst part is these
will get worse as your user count increases, are difficult to reproduce,
and usually happen to your most critical pieces of code.

As an example, let's assume you're writing an app to enable students to enroll
in courses online.  You need to ensure that no more than 30 people can sign
up for a given class.  In your enrollment code, you have something like this:

    @course = Course.find(1)
    if @course.num_students < 30
      @course.course_students.create(:student_id => 101)
      @course.num_students += 1
      @course.save!
    else
      # course is full
    end
    
You're screwed.  You now have 32 people in your 30 person class, and you have
no idea what happened.

The easiest way to spot race conditions is ask whether somebody else could
access a given data structure _in_ _between_ _each_ _line_ _of_ _code_, and whether
that would cause problems.  Here's one way to visualize it:

  @course = Course.find(1)
  course_client1 = Course.find(1)
  if @course.num_students < 30
    course_client2 = Course.find(1)
    @course.course_students.create(:user_id => 101)
    course_client3 = Course.find(1)
    @course.num_students += 1
    course_client4 = Course.find(1)
    @course.save!
  else
    # course is full
  end

The +course_clientN+ variables represent access to that course from other
clients concurrently with the original client.  As you can see, there's
a ton of potential for that "< 30" check to be true even when the course
is full.

As a rule of thumb: Any operation that changes a value *must* return that
value in the same operation.  If you do a separate get then set, or
set then get, you're open to a race condition.  There are very few
systems that support a "getset" type operation, and Redis is one of them
(Oracle DB sequences are another).

In the specific example above, you could lock the +Course+ record.  In
ActiveRecord that would look like this:

    @course = Course.find(1, :lock => true)
    if @course.num_students < 30
      @course.course_students.create(:student_id => 101)
      @course.num_students += 1
      @course.save!
    else
      # course is full
    end

But now you've introduced other issues.  Any other piece of code that needs
to update anything about the course - for example, maybe the course name, or
start date, or location - is now serialized.  If you need high concurrency,
once again you're screwed.

What you need is a way to handle very specific conditions atomically, which
is what this gem provides.

== A Better Way

Think of the specific things that you need to ensure.  Many of these will
reduce to numeric operations.  For example:

* No more than 30 students in a course
* Must have more than 2 but less than 6 people in a game
* A chat room has a max of 50 people
* Correctly recording the total number of blog posts
* Only allowing one piece of code to reorder a large dataset at a time

All except the last one can be implemented with counters.  The last one 
will need a carefully placed lock.

The best way I've found to balance atomicity and concurrency is to split
your counters into two types:

* Counters users see (eg, +current_students+).  These typically increment.
* Counters you base logic on (eg, +remaining_slots+).  These typically decrement.

The reason you want two counters is you need to change the value of the logic
counter *FIRST*, _before_ checking it and doing stuff.  This means the value
can get wonky momentarily.  If not, again, you're open to a race condition.

So, taking our +Course+ example:

    class Course < ActiveRecord::Base
      include Redis::Atoms
      
      counter :remaining_slots, :start => 30
      counter :current_students
    end

Then:

    @course = Course.find(1)
    @course.if_remaining_slots_left do
      @course.course_students.create!(:student_id => 101)
      @course.increment_current_students
    end

That way, your views get consistent information about the course, since
+current_students+ will only be incremented on success.  There is still a
race condition where it could be less than the real number of +CourseStudent+
records, but because you will (very likely) be using this in a fetched-record
context in a view, you won't see this manifest in real-world usage. 

== Author

Copyright (c) 2009 {Nate Wiger}[http://nate.wiger.org].  All Rights Reserved.
Released under the {Artistic License}[http://www.opensource.org/licenses/artistic-license-2.0.php].
